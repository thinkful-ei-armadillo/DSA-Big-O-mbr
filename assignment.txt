1) 1) O(1) because time does not change
   2) O(n) because you need to talk to each person

2) O(1) there is only one value, time is independent

3) O(n^2) nested loops

4) O(n) runtime is proportional to size

5) O(n) runtime is proportional to size

6) O(n^2) nested loops

7) This algorithm returns an array of the fibonacci sequence. O(n) runtime is linear, as it needs to go through the entire array to find result.

8) O(log(n)) cuts amount of items to search in half

9) O(1) grabs one item from array, no matter the length

10) This algorithm returns prime numbers. O(n) loops through until it finds a prime number.

13) 1) O(n) because loop is dependent on number of sheep
    2) O(n) because loop is dependent on number of exponent
    3) O(n) because loop is dependent on length of string
    4) O(n) because loop is dependent on number of input
    5) O(n) because loop is dependent on length of string
    6) O(n) because loop is dependent on number of input
    7) O(n) because input is limiting factor

14) 2) isEven has constant run time complexity (O(1))
    3) areYouHere has polynomial run time complexity (O(n^2))
    4) doubleArrayValues has linear run time complexity (O(n))
    5) naiveSearch has linear run time complexity (O(n))
    6) createPairs has polynomial run time complexity (O(n^2))
    7) compute has linear run time complexity (O(n))
    8) efficientSearch has logarithmic run time complexity (O(log n))
    9) findRandomElement has constant run time complexity (O(1)).
    10) isWhat has linear run time complexity (O(n))